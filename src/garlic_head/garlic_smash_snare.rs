use crate::garlic_crust::*;
use super::*;
use crate::garlic_helper::*;

// Garlic Smashsare Drum Synth Cloves
// they are monosynths by design
// and use pattern functions for triggering instead of NoteOn Sequences

// the member fields
pub struct SmashState {
    pub output: BlockArray,
    pub volume: MonoSample,

    osc: oscillator::Oscillator,
    osc_output: Edge,

    noise_osc: oscillator::Oscillator,
    noise_osc_output: Edge,

    env_vca: envelope::Envelope,
    env_vca_output: Edge,

    env_freq: envelope::Envelope,
    env_freq_output: Edge,

    dist: Edge,
    quad_shape: QuadWaveShape,
    overall_volume: Edge,

    lp: filter::Filter,
    lp_output: Edge,
}

pub fn create_state() -> SmashState {
    SmashState {
        output: EMPTY_BLOCKARRAY,
        volume: 0.4, // could be parameter in create_state

        osc: oscillator::Oscillator {
            frequency: Edge::zero(),
            detune: Edge::constant_stereo([0., 0.02]),
            phasemod: Edge::constant_stereo([0.3, 0.]),
            shape: oscillator::BaseWave::Sine,
            ..Default::default()
        },
        osc_output: Edge::zero(),

        noise_osc: oscillator::Oscillator {
            shape: oscillator::BaseWave::PerlinNoise(200.),
            ..Default::default()
        },
        noise_osc_output: Edge::zero(),

        env_vca: envelope::Envelope {
            shape: envelope::EnvShape::Generic {
                func: snare_amp_env
            },
            ..Default::default()
        },
        env_vca_output: Edge::zero(),

        env_freq: envelope::Envelope {
            shape: envelope::EnvShape::Generic {
                func: snare_freq_env
            },
            ..Default::default()
        },
        env_freq_output: Edge::zero(),

        dist: Edge::constant(50.),
        quad_shape: QuadWaveShape::create(0., 0.2, 0.4, -0.4, 0.24, 0.05, 0.7),
        overall_volume: Edge::zero(),

        lp: filter::Filter {
            shape: filter::FilterType::LowPass,
            cutoff: Edge::constant(1000.),
            ..Default::default()
        },
        lp_output: Edge::zero(),
    }
}

const A: f32 = 0.001;
const AD: f32 = 0.12;

fn snare_amp_env(t: TimeFloat) -> MonoSample {
    match t {
        x if x < A => crate::math::slope(t, 0., A, 0., 1.),
        x if x < AD => crate::math::powerslope(t, A, AD, 1., 0., 0.4),
        _ => 0.

    }
}

const START_FREQ: f32 = 3000.;
const END_FREQ: f32 = 100.;

fn snare_freq_env(t: TimeFloat) -> MonoSample {
    match t {
        x if x < A => START_FREQ,
        x if x < AD => crate::math::logslope(x, A, AD, START_FREQ, END_FREQ),
        _ => END_FREQ,
    }
}

/* process() is the heart of the Garlic Smash and will be generated by knober
 *
 * unclear: management of seq_cursor, output could also be in the GarlicSmashState. think about.
 * sequence would then have to be split into the blocks itself, but this could be done by garlic_extract. meh
 *
 */
#[inline]
pub fn process(block_offset: usize, state: &mut SmashState) {

    process_operator_dyn(&mut state.env_vca, &trigger, block_offset, &mut state.env_vca_output);
    state.osc.volume = state.env_vca_output;

    process_operator_dyn(&mut state.env_freq, &trigger, block_offset, &mut state.env_freq_output);
    state.osc.frequency = state.env_freq_output;

    //process_operator(&mut state.noise_osc, &mut state.noise_osc_output); // wÃ¶rks not, can't care now
    // try this way:
    generate_from_func(perlin_noise, block_offset, &mut state.noise_osc_output);
    state.osc.phasemod = state.noise_osc_output;

    process_operator(&mut state.osc, &mut state.osc_output);

    state.lp.input = state.osc_output;
    process_operator(&mut state.lp, &mut state.lp_output);

    waveshape_quad(&mut state.lp_output, &state.quad_shape);

    math_overdrive(&mut state.lp_output, &state.dist);

    generate_from_func(overall_volume, block_offset, &mut state.overall_volume);
    state.lp_output.multiply(&state.overall_volume);

    state.lp_output.write_to(&mut state.output, state.volume);
}

/* trigger() holds, as a mathematical function, the repetition pattern of the kick.
 * it will be produced by dynamo210 some day.
*/
#[inline]
pub fn trigger(total_sample: usize) -> bool {
    // TOOD: give velocity information procedurally, somehow
    match DYNAMO.beat(total_sample) + 1. {
        b if b >= 11. && b < 18. => {
            let beat_inside = libm::fmodf(b, 2.);
            let quarter_beat = libm::fmodf(b, 0.5);
            quarter_beat < INV_SAMPLERATE && beat_inside < 1.5
        },
        b if b >= 21. && b < 44. => {
            let b_quarter = libm::fmodf(b, 0.25);
            let b_inside = libm::fmodf(b + 0.25, 0.5);
            b_quarter < INV_SAMPLERATE && b_inside < INV_SAMPLERATE // || libm::fmodf(b + 0.125, 1.) < INV_SAMPLERATE
        }
        b if b < 44. => {
            let b_5 = libm::fmodf(b, 0.5);
            libm::fmodf(b, 0.25) < INV_SAMPLERATE && b_5 > 0.25
        }
        _ => false,
    }
}

fn perlin_noise(t: TimeFloat) -> Sample {
    let result = 4. * crate::math::lpnoise(t, 2000.);

    let amountL = 0.5 + 0.5 * libm::cosf(crate::math::TAU * t * 2.4);

    [result * amountL, result * (1. - amountL)]
}

fn overall_volume(t: TimeFloat) -> Sample {
    let result = match t {
        _t if _t < 11. => crate::math::slope(_t, 0., 11., 0., 1.),
        _t if t > 11. => 1.,
        _ => 0.
    };

    [result, result]
}
