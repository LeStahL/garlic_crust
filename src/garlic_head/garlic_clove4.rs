use crate::garlic_crust::*;
use crate::garlic_helper::*;
use super::*;

pub struct CloveState {
    pub output: BlockArray,
    pub volume: MonoSample,

    osc: oscillator::Oscillator,
    osc_output: Edge,

    freq_env: envelope::Envelope,
    freq_env_output: Edge,
    freq_env_amount: Edge,

    env: envelope::Envelope,
    env_output: Edge,

    env_duck: envelope::Envelope,
    env_duck_output: Edge,

    lp: filter::Filter,
    lp_output: Edge,
}

pub fn create_state() -> CloveState {
    CloveState {
        output: EMPTY_BLOCKARRAY,
        volume: 0.3,

        osc: oscillator::Oscillator {
            shape: oscillator::BaseWave::Square,
            freq_factor: Edge::constant(0.5),
            detune: Edge::constant_stereo([0.,0.005]),
            phasemod: Edge::constant_stereo([-0.04,0.1]),
            ..Default::default()
        },
        osc_output: Edge::zero(),

        freq_env: envelope::Envelope {
            shape: envelope::EnvShape::Sinc {
                gain: Edge::constant(20.0),
                period: Edge::constant(0.0012),
                suppression: Edge::constant(1.8)
            },
            ..Default::default()
        },
        freq_env_output: Edge::zero(),
        freq_env_amount: Edge::zero(),

        env: envelope::Envelope {
            shape: envelope::EnvShape::Common {
                base: envelope::BaseEnv::ExpDecay,
                attack: Edge::constant(0.04),
                decay: Edge::constant(0.4),
                sustain: Edge::constant(0.2),
            },
            ..Default::default()
        },
        env_output: Edge::zero(),

        env_duck: envelope::Envelope {
            shape: envelope::EnvShape::Common {
                base: envelope::BaseEnv::Swell,
                sustain: Edge::constant(30.),
                attack: Edge::constant(0.24),
                decay: Edge::zero(),
            },
            ..Default::default()
        },
        env_duck_output: Edge::zero(),

        lp: filter::Filter {
            shape: filter::FilterType::LowPass,
            cutoff: Edge::constant(500.),
            ..Default::default()
        },
        lp_output: Edge::zero(),
    }
}

/* process() is the heart of the Garlic Clove and will be generated by knober
 *
 * unclear: management of seq_cursor, output could also be in the GarlicClove1State. think about.
 * sequence would then have to be split into the blocks itself, but this could be done by garlic_extract. meh
 *
 */

#[inline]
pub fn process(sequence: &[SeqEvent], block_offset: usize, state: &mut CloveState) {
    generate_from_func(func_phasemod_gain, block_offset, &mut state.freq_env_amount);

    // generate_from_func_mono(func_volume, block_offset, )

    process_operator_dyn(&mut state.env_duck, &super::garlic_smash_kick::trigger, block_offset, &mut state.env_duck_output); // "side chain" means: get garlic_smash trigger as input, not a sequence

    process_operator_seq(&mut state.freq_env, &sequence, block_offset, &mut state.freq_env_output);
    state.osc.phasemod = state.freq_env_output;
    state.osc.phasemod.multiply(&state.freq_env_amount);

    process_operator_seq(&mut state.env, &sequence, block_offset, &mut state.env_output);
    state.osc.volume = state.env_output;
    process_operator_seq(&mut state.osc, &sequence, block_offset, &mut state.osc_output);

    state.lp.input = state.osc_output;
    process_operator(&mut state.lp, &mut state.lp_output);

    state.lp_output.multiply(&state.env_duck_output); // irgendeine Verkackung, kann ich grad nicht prÃ¼fen

    state.lp_output.write_to(&mut state.output, state.volume);
}

fn func_phasemod_gain(t: TimeFloat) -> Sample {
    let result = match t {
        t if t < 17. => { crate::math::powerslope(t, 0.0, 17.0, 9000., 100.0, 0.25) }
        _ => { 100.0 }
    };
    let amountL = 0.5 + 0.5 * libm::cosf(crate::math::TAU * t * 2.4);
    [result * amountL, result * (1. - amountL)]
}

