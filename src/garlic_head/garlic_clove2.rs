use crate::garlic_crust::*;
use super::*;
use crate::garlic_helper::*;

// A garlic clove is basically a garlic crust "preset", i.e. its internal wiring

// the member fields
pub struct Clove2State {
    pub output: BlockArray,
    pub volume: MonoSample,

    sub: oscillator::Oscillator,
    sub_output: Edge,

    osc1: oscillator::Oscillator,
    osc1_output: Edge,

    env1: envelope::Envelope,
    env1_output: Edge,

    osc2: oscillator::Oscillator,
    osc2_output: Edge,

    env2: envelope::Envelope,
    env2_output: Edge,

    lp: filter::Filter,
    lp_output: Edge,
}

pub fn create_state() -> Clove2State {
    Clove2State {
        output: EMPTY_BLOCKARRAY,
        volume: 0.05,

        sub: oscillator::Oscillator {
            shape: oscillator::BaseWave::Sine,
            freq_factor: Edge::constant(0.25),
            detune: Edge::constant_stereo([0.051, -0.0746]),
            phasemod: Edge::constant_stereo([0.4, -0.003]),
            ..Default::default()
        },
        sub_output: Edge::zero(),

        osc1: oscillator::Oscillator {
            shape: oscillator::BaseWave::Square,
            volume_factor: [0.3, 0.3],
            ..Default::default()
        },
        osc1_output: Edge::zero(),

        env1: envelope::Envelope {
            shape: envelope::EnvShape::Common {
                base: envelope::BaseEnv::Swell,
                attack: Edge::constant(0.6),
                decay: Edge::zero(),
                sustain: Edge::constant(3.),
            },
            ..Default::default()
        },
        env1_output: Edge::zero(),

        osc2: oscillator::Oscillator {
            shape: oscillator::BaseWave::Sine,
            volume: Edge::constant(1.),
            volume_factor: [3., 3.],
            freq_factor: Edge::constant(0.5),
            ..Default::default()
        },
        osc2_output: Edge::zero(),

        env2: envelope::Envelope {
            shape: envelope::EnvShape::Common {
                base: envelope::BaseEnv::ExpDecay,
                attack: Edge::constant(0.26),
                decay: Edge::constant(0.22),
                sustain: Edge::constant(0.5),
            },
            ..Default::default()
        },
        env2_output: Edge::zero(),

        lp: filter::Filter {
            shape: filter::FilterType::LowPass,
            cutoff: Edge::constant(1000.),
            ..Default::default()
        },
        lp_output: Edge::zero(),
    }
}

/* process() is the heart of the Garlic Clove and will be generated by knober
 *
 * unclear: management of seq_cursor, output could also be in the GarlicClove2State. think about.
 * sequence would then have to be split into the blocks itself, but this could be done by garlic_extract. meh
 *
 */

#[inline]
pub fn process(sequence: &[SeqEvent], block_offset: usize, state: &mut Clove2State) {
    // these function generates replace the former Edge::functions(), i.e. "math-generated parameters".
    //generate_from_func(func_osc_phasemod, block_offset, &mut state.osc_osc1.phasemod);

    // first branch - carrier
    process_operator_dyn(&mut state.env1, &super::garlic_smash::trigger, block_offset, &mut state.env1_output); // "side chain" means: get garlic_smash trigger as input, not a sequence

    process_operator_seq(&mut state.sub, &sequence, block_offset, &mut state.sub_output);

    // second branch - modulator
    process_operator_dyn(&mut state.env2, &super::garlic_smash::trigger, block_offset, &mut state.env2_output); // "side chain" means: get garlic_smash trigger as input, not a sequence
    state.osc2.volume = state.env2_output;
    process_operator_seq(&mut state.osc2, &sequence, block_offset, &mut state.osc2_output);

    state.osc1.volume = state.env1_output;
    state.osc1.phasemod = state.osc2_output;
    process_operator_seq(&mut state.osc1, &sequence, block_offset, &mut state.osc1_output);

    state.sub_output.mad(&state.env1_output, &state.osc1_output);
    math_overdrive_const(&mut state.sub_output, 3.);

    // state.lp.input = state.osc1_output;
    // process_operator(&mut state.lp, &mut state.lp_output);

    state.sub_output.write_to(&mut state.output, state.volume);
    //state.osc1_output.write_to(&mut state.output, state.volume);
}

// custom functions as required...

fn func_osc_phasemod(t: TimeFloat) -> Sample {
    [
        0.02 * libm::sinf(4.*t),
        0.02 * libm::sinf(4.*t)
    ]
}
